# 자바스크립트 문법 정리 2

# Truthy & Falsy

자바스크립트에서 Truthy(참 같은 값)와Falsy(거짓 같은 값)는 불리언(true 또는 false)이 아닌 값이지만, **조건문에서 불리언 값처럼 취급되는 값**을 말한다

 **Falsy 값 :**

false — 불리언 false 자체

0 — 숫자 0

0 — 음의 0

0n — BigInt형의 0

"", '', ```` — 빈 문자열

null — 값이 없음을 나타냄

undefined — 정의되지 않은 값

NaN — 숫자가 아님을 나타냄
위 8가지 값을 제외한 나머지 값들은 모두 Truthy로 간주

let 이름 = "";   <<이름이 빈 문자열이기 때문에 Falsy

if (이름) {
console.log(`안녕하세요, ${이름}님!`);
} else {
console.log("이름을 입력해주세요.");
}
// 출력: 이름을 입력해주세요.

# 단락평가 (어렵

**단락 평가**는 자바스크립트에서 **논리 연산자**(&&, ||)를 사용할 때, **왼쪽 값에 따라 오른쪽 값을 평가하지 않을 수 있는 동작**을 말한다

**1. && (AND 연산자)**

왼쪽 값이 Falsy면 전체 결과가 이미 false이므로 오른쪽 값을 평가하지 않는다

**2. || (OR 연산자)**

왼쪽 값이 Truthy면 전체 결과가 이미 true이므로 오른쪽 값을 평가하지 않는다

# 객체 자료형 자세히

**객체 자료형**: 원시 자료형을 제외한 모든 것

**배열**과 **함수**도 **객체 자료형**

배열은 **순서대로 값을 저장**하는 데 특화된 **객체,** 다른 언어의 배열처럼 동작하도록 **객체에 몇 가지 기능이 추가된 형태다**

그래서 배열은 일반 객체처럼 **프로퍼티(속성)**와 **메서드(동작)**를 가지고 있다

let 배열 = [1, 2, 3];

console.log(배열.length); // 속성: 배열의 길이 출력 (3)
배열.push(4);             // 메서드: 배열에 값 추가
console.log(배열);        // 출력: [1, 2, 3, 4]

**함수도 객체다.** 함수는 **실행 가능한 코드 블록**이지만, 자바스크립트에서는 **객체처럼 취급**된다.

함수도 프로퍼티와 메서드를 가질 수 있다.

function 인사() {
console.log("안녕하세요!");
}

인사.설명 = "이 함수는 인사말을 출력합니다.";

console.log(인사.설명); // 출력: 이 함수는 인사말을 출력합니다.

**-원시 자료형과 객체 자료형의 저장 방식 비교**

**원시 자료형:**

**값 자체**를 메모리에 저장한다. 예를 들어, let a = 10; 이라고 하면, 변수 a는 메모리 어딘가에 숫자 10을 직접 저장한다.

**객체 자료형:**

**참조(Reference)**를 사용하여 값을 저장한다. 객체의 실제 데이터는 메모리의 다른 곳에 저장되고, 변수에는 그 **주소**만 저장된다.

예를 들어, let obj = { name: "홍길동" }; 이라고 하면: 객체 { name: "홍길동" }은 메모리의 어딘가에 저장되고, 변수 obj는 그 객체의 **메모리 주소**를 가지고 있다.

참조 사용 이유: 객체는 안에 포함된 데이터가 늘어나거나 줄어들 수 있다. **효율성,** 큰 데이터를 복사하지 않고 **주소만 전달**하면 메모리를 효율적으로 사용할 수 있다.

let obj1 = { value: 5 };
let obj2 = obj1;

obj2.value = 10;

console.log(obj1.value); // 출력: 10
console.log(obj2.value); // 출력: 10

# 반복문 응용

### **배열과 반복문**

**배열과 인덱스**

**배열**은 여러 데이터를 순서대로 저장하는 구조,

각 데이터는 **인덱스(index)**라는 번호로 접근할 수 있다.  **인덱스는 0부터 시작**

let arr = [1, 2, 3, 4];  여기서 arr[0]은 1, arr[1]은 2를 나타냄

**1. 인덱스를 이용한 순회**

let arr = [1, 2, 3, 4];

for (let idx = 0; idx < 4; idx++) {
console.log(arr[idx]);
}

// 출력:
// 1
// 2
// 3
// 4

idx를 0부터 3까지 증가시키면서 arr[idx]로 배열의 각 요소를 출력한다. (여기서 4는 배열의 길이)

-배열의 길이가 변하면 for (let idx = 0; idx < 4; idx++)처럼 길이를 **직접 숫자로 쓰면** 문제가 생길 수 있다.

let food = ["짜장면", "피자", "치킨"];

for (let i = 0; i < food.length; i++) {
console.log(food[i]);
}

// 출력:
// 짜장면
// 피자
// 치킨

food.length를 사용하여 배열의 길이를 동적으로 가져온다

배열의 길이가 변해도 food.length가 그에 맞게 변하므로 안전하게 모든 요소를 순회할 수 있다

**주의할 점: 반복문의 조건식**

•배열의 인덱스는 **0부터 시작**하고, 마지막 인덱스는 **배열의 길이보다 1 작다.**

•따라서 반복문의 조건은 i < 배열.length로 해야 함

•**잘못된 조건식**: i <= 배열.length로 하면 배열 범위를 넘어선 인덱스에 접근하게 되어 undefined가 나올 수 있다.

// 올바른 방법
for (let i = 0; i < food.length; i++) {
console.log(food[i]);
}

// 잘못된 방법
for (let i = 0; i <= food.length; i++) {
console.log(food[i]); // 마지막에 undefined 출력됨
}

i <= food.length로 하면 i가 food.length까지 증가하므로, food[3]에 접근하게 되는데, 인덱스 3은 존재하지 않는다(배열의 인덱스는 0, 1, 2까지만 있음).

**객체를 반복문으로 순회하기**

**-Object.keys를 사용하여 키(key) 순회하기**

Object.keys(객체) 메서드는 객체의 **키들만 모은 배열**을 반환합니다.

let person = {
name: "이정환",
age: 25,
location: "경기도"
};

const keyArr = Object.keys(person); // 키들의 배열을 얻음
console.log(keyArr); // 출력: ["name", "age", "location"]

이 keyArr 배열을 for...of **반복문**으로 순회할 수 있다.

for (let key of keyArr) {
console.log(key);
}

// 출력:
// name
// age
// location

**-키와 값을 함께 사용하기**

**대괄호 표기법**을 사용하여 키를 통해 **값(value)**을 가져올 수 있다.

for (let key of keyArr) {
let value = person[key]; // 키를 사용하여 값에 접근
console.log(key, value);
}

// 출력:
// name 이정환
// age 25
// location 경기도

-**Object.values를 사용하여 값(value)만 순회하기**

const valueArr = Object.values(person); // 값들의 배열을 얻음
console.log(valueArr); // 출력: ["이정환", 25, "경기도"]

for (let value of valueArr) {
console.log(value);
}

// 출력:
// 이정환
// 25
// 경기도

-**for...in 문을 사용하여 객체 순회하기**

for (let key in person) {
const value = person[key];
console.log(key, value);
}

// 출력:
// name 이정환
// age 25
// location 경기도

# 구조 분해 할당

**배열이나 객체 안에 있는 값을 꺼내서 간편하게 변수에 담는 방법,** 복잡한 코드를 **더 짧고 간단하게** 만들 수 있다.

**-배열의 구조 분해 할당**

기존 방법:

let arr = [1, 2, 3];

let 첫번째 = arr[0];
let 두번째 = arr[1];
let 세번째 = arr[2];

console.log(첫번째, 두번째, 세번째); // 출력: 1 2 3

구조 분해 할당:

let arr = [1, 2, 3];

let [첫번째, 두번째, 세번째] = arr;

console.log(첫번째, 두번째, 세번째); // 출력: 1 2 3

-**객체의 구조 분해 할당**

let 사람 = {
이름: "홍길동",
나이: 30,
직업: "모험가"
};

기존 방법:

let 이름 = 사람.이름;
let 나이 = 사람.나이;
let 직업 = 사람.직업;

console.log(이름, 나이, 직업); // 출력: 홍길동 30 모험가

구조 분해 할당:

let { 이름, 나이, 직업 } = 사람;

console.log(이름, 나이, 직업); // 출력: 홍길동 30 모험가

-**함수 매개변수에서 사용하기**

function 소개({ 이름, 나이 }) {
console.log(`안녕하세요, 저는 ${이름}이고, 나이는 ${나이}살입니다.`);
}

let 사람 = {
이름: "홍길동",
나이: 30,
직업: "모험가"
};

소개(사람); // 출력: 안녕하세요, 저는 홍길동이고, 나이는 30살입니다.

# 스프레드 연산자

**스프레드 연산자**는 자바스크립트에서 ... **점 세 개**로 표현

**묶여 있는 것들을 하나씩 펼쳐주는 역할,** 배열이나 객체 안의 **내용물을 펼쳐서 사용**할 수 있다.

let 바구니1 = ["사과", "바나나"];

let 바구니2 = [...바구니1, "오렌지", "포도"];

=그래서 바구니2는 ["사과", "바나나", "오렌지", "포도"]

**객체에서도 사용 가능**

let 사람1 = { 이름: "홍길동", 나이: 30 };

let 사람2 = { ...사람1, 직업: "모험가" };

=그래서 사람2는 { 이름: "홍길동", 나이: 30, 직업: "모험가" }

**함수에서도 사용 가능**

function 더하기(a, b, c) {
return a + b + c;
}

let 숫자들 = [1, 2, 3];

let 결과 = 더하기(...숫자들);
console.log(결과); // 출력: 6

=...숫자들은 [1, 2, 3]을 1, 2, 3으로 펼쳐서 함수에 넣음, 그래서 더하기(1, 2, 3);과 같은 효과

## **Rest(나머지) 매개변수란?**

**Rest 매개변수**도 ...로 표시하지만, **함수의 매개변수에서** 사용

function 더하기(...숫자들) {
let 합계 = 0;
for (let 숫자 of 숫자들) {
합계 += 숫자;
}
return 합계;
}

let 결과 = 더하기(1, 2, 3, 4, 5);
console.log(결과); // 출력: 15

# 배열과 매서드

### **배열 요소 추가 및 제거 메서드**

**1. push():배열 끝에 요소를 추가**합니다.

arr.push(요소);

**2. pop():배열 끝에서 요소를 제거**하고, 그 요소를 반환합니다.

arr.pop();

**3. unshift():배열 앞에 요소를 추가**합니다.

arr.unshift(요소);

**4. shift():배열 앞에서 요소를 제거**하고, 그 요소를 반환합니다.

arr.shift();

### **배열을 자르거나 합치는 메서드**

**1. slice(start, end):**배열의 일부를 **잘라서 새로운 배열**을 만듭니다/start부터 end **전까지** 자릅니다

arr.slice(시작인덱스, 끝인덱스);

**2. concat():배열을 합쳐서 새로운 배열**을 만듭니다.

arr1.concat(arr2);

### **배열 순회 메서드**

**forEach():**배열의 **각 요소를 순서대로 처리**합니다.

arr.forEach(요소 => {
// 처리할 내용
});

### **배열에서 값 찾기 메서드**

**1. indexOf(값):특정 값의 인덱스**를 찾습니다/없으면 -1을 반환합니다.

arr.indexOf(값);

**2. includes(값):**배열에 **특정 값이 있는지 확인**합니다.

arr.includes(값);

**3. findIndex(조건함수):조건을 만족하는 첫 번째 요소의 인덱스**를 찾습니다.

arr.findIndex(요소 => 조건);

**4. find(조건함수):조건을 만족하는 첫 번째 요소**를 찾습니다.

arr.find(요소 => 조건);

**5. filter(조건함수):조건을 만족하는 모든 요소를 새로운 배열**로 만듭니다.

arr.filter(요소 => 조건);

### **배열 변형 메서드**

**1. map(변환함수):**배열의 각 요소를 **변환하여 새로운 배열**을 만듭니다.

arr.map(요소 => 변환값);

**2. sort(비교함수):**배열을 **정렬**

arr.sort();
arr.sort((a, b) => a - b); // 숫자 오름차순 정렬

**3. join(구분자):**배열의 요소를 **문자열로 합쳐서 반환**

arr.join('구분자');

**4. reduce(누적함수, 초기값):**배열의 모든 요소를 **하나의 값으로 합침**

arr.reduce((누적값, 현재값) => 새로운누적값, 초기값);

# Date객체와 날짜

**-Date 객체 생성하기**

**1. 현재 날짜와 시간 생성**

let now = new Date();
console.log(now); // 현재 날짜와 시간이 출력

=new Date()를 사용하면 **현재 날짜와 시간**을 가진 Date 객체가 생성

**2. 특정 날짜와 시간 생성**

let date = new Date("2021-12-25");
console.log(date); // 2021년 12월 25일이 출력

=문자열로 날짜를 전달하면 해당 날짜의 Date 객체가 생성

let date = new Date(2021, 11, 25);
console.log(date); // 2021년 12월 25일이 출력

=new Date(연도, 월, 일) 형식으로 숫자를 전달 <월은 **0부터 시작**해서 0이 1월, 11이 12월>

-**Date 객체에서 날짜와 시간 얻기**

getFullYear(): 연도를 가져옴

getMonth(): 월을 가져옴 (0부터 11까지)-11 (12월)

getDate(): 일을 가져옴

getDay(): 요일을 가져옴 (0부터 6까지, 0은 일요일)-6 (토요일)

getHours(), getMinutes(), getSeconds(): 시, 분, 초를 가져옴

-**Date 객체의 날짜와 시간 설정하기**

setFullYear(연도): 연도 설정-date.setFullYear(2022);

setMonth(월): 월 설정 (0부터 11까지)-0(1월)

setDate(일): 일 설정

setHours(시), setMinutes(분), setSeconds(초): 시, 분, 초 설정

-**Date 객체를 문자열로 변환하기**

toString(): Date 객체를 문자열로 변환 = console.log(date.toString());

toDateString(): 날짜만 문자열로 변환 = console.log(date.toDateString()); // 예: "Sat Dec 25 2021”

toLocaleString(): 지역 설정에 맞게 날짜와 시간을 문자열로 변환 = console.log(date.toLocaleString()); // 예: "2021. 12. 25. 오후 12:30:00”

-**타임스탬프 사용하기**

**타임스탬프**는 1970년 1월 1일부터 경과한 밀리초(ms)를 의미

getTime(): Date 객체를 타임스탬프로 변환

let timestamp = date.getTime();

new Date(밀리초): 타임스탬프로 Date 객체를 생성

let dateFromTimestamp = new Date(timestamp);

# 비동기 처리

-**동기: 순서대로 실행되는 것,** 코드가 **위에서 아래로 차례대로** 실행됨

console.log("1번"); // 출력: 1번
console.log("2번"); // 출력: 2번
console.log("3번"); // 출력: 3번

**-비동기: 동시에 실행될 수 있는 것,** 앞의 작업이 끝날 때까지 기다리지 않고 **다른 작업을 진행**

setTimeout(() => {
console.log("1번!");
}, 1000);

console.log("2번!");

-

2번!
(1초 후) 1번!

**-비동기 코드 작성하기**

**1. 콜백 함수 사용하기**

function 작업(콜백) {
setTimeout(() => {
콜백("완료");
}, 1000);
}

작업((결과) => {
console.log(결과); // 출력: 완료
});

console.log("작업 요청");

작업 요청
(1초 후) 완료

**2. Promise 사용하기**

const 약속 = new Promise((resolve, reject) => {
setTimeout(() => {
resolve("성공");
}, 1000);
});

약속.then((결과) => {
console.log(결과); // 출력: 성공
});

console.log("약속 대기");

약속 대기
(1초 후) 성공