# 자바스크립트 문법 정리

# **변수와 상수**

Var,let,const 키워드를 사용해서 선언 가능

Var 이름 = “ 000 “;

- 재선언과 재할당이 모두 가능하다
- 함수 스코프를 가진다. 즉, 함수 내에서만 유효하다

Let 나이 = 25;

- 재할당은 가능하지만 재선언은 불가능하다
- 블록 스코프를 가진다. 중괄호 {} 안에서만 유효하다

let 이름 = "홍길동";

console.log(이름); // 출력: 홍길동

이름 = "김철수";

console.log(이름); // 출력: 김철수

Const 학교 = 000; (상수를 선언할 때 사용, 선언 후 값을 변경할 수 없다)

- 재선언과 재할당 모두 불가능하다
- 블록 스코프를 가진다. 중괄호 {} 안에서만 유효하다

const 생일 = "2000-01-01";

console.log(생일); // 출력: 2000-01-01

생일 = "1999-12-31"; // 오류 발생: 상수는 값을 변경할 수 없음

(함수 스코프:변수는 함수 내부 전체에서 유효합니다,함수 내부 어디에서든 변수에 접근할 수 있습니다.)

(블록 스코프:변수는 블록 {} 내부에서만 유효합니다,블록 외부에서는 변수에 접근할 수 없습니다.)

if (true) {

var 변수1 = "안녕";

let 변수2 = "반가워";

const 변수3 = "잘 있어";

}

console.log(변수1); // 출력: 안녕

console.log(변수2); // 오류 발생: 변수2는 정의되지 않음

console.log(변수3); // 오류 발생: 변수3는 정의되지 않음

let은 변경 가능한 변수를 선언할 때 사용한다.

const는 변경 불가능한 상수를 선언할 때 사용한다.

var은 가능하면 사용을 피하고, let과 const를 사용하는 것이 요즘 코딩 방식이다.

# **자료형**

자료형은 **데이터의 종류**

컴퓨터는 숫자, 문자, 참/거짓 등의 다양한 데이터를 다루는데, 자바스크립트에서는 이러한 데이터들을 구분하기 위해 자료형을 사용합니다.

자바스크립트의 자료형은 원시 타입(Primitive Type)과 객체 타입(Object Type)으로 나눌 수 있습니다.

- 숫자(number): 숫자를 나타냅니다. 정수와 소수점을 포함한 실수를 모두 표현할 수 있습니다.
- 문자열(string):문자를 나타냅니다. 텍스트 데이터를 저장할 때 사용합니다. (작은따옴표(’’), 큰따옴표(””), 백틱(``)으로 묶습니다)
- 불리언(boolean):참 또는 거짓을 나타냅니다. 논리적 판단이 필요한 경우 사용합니다. (true(참), false(거짓))
- undefined:값이 **정의되지 않음**을 나타냅니다/변수를 선언했지만 값을 할당하지 않은 경우

let 값;

console.log(값); // 출력: undefined

- null:**값이 없음을** 의도적으로 나타냅니다.

let 데이터 = null;

console.log(데이터); // 출력: null

- 객채(object):여러 값을 **키(key)와 값(value)**의 형태로 저장할 수 있는 복잡한 데이터 구조입니다.

let 사람 = {

이름: "홍길동",

나이: 25,

학생인가요: true,

}

- 배열(array):순서가 있는 리스트 형태로 여러 값을 저장할 수 있습니다.

let 과일들 = ["사과", "바나나", "포도"];

- 심볼(symbol):고유한 식별자를 만들 때 사용합니다

let 아이디 = Symbol("id");

# **형 변환**

**형 변환**은 **데이터의 자료형(Data Type)을 다른 자료형으로 바꾸는 것**

예를 들어, 문자열 "123"을 숫자 123으로 바꾸거나, 숫자 0을 불리언 false로 바꾸는 것 등이 있습니다.

**명시적 형 변환 (Explicit Conversion)**: 개발자가 코드를 통해 명확하게 형 변환을 수행하는 것.

**묵시적 형 변환 (Implicit Conversion)**: 자바스크립트 엔진이 자동으로 형 변환을 수행하는 것.

- 명시적 형 변환은 우리가 직접 함수를 사용하여 자료형을 변환하는 것을 말합니다.

**숫자로 변환**

- Number() **함수 사용**
- ****parseInt()**와** parseFloat() **함수 사용**

**문자열로 변환하기**

- ****String() **함수 사용**
- ****toString() **메서드 사용**

**불리언으로 변환**

- ****Boolean() **함수 사용**
- 암시적 형 변환은 자바스크립트가 특정 상황에서 자동으로 자료형을 변환하는 것입니다.

**문자열과 숫자의 연산**

덧셈연산자:덧셈 연산자 +는 문자열 연결에도 사용되기 때문에, 피연산자 중 하나가 문자열이면 문자열 연결로 동작합니다.

let 결과 = "5" + 2;

console.log(결과); // "52" (문자열로 변환되어 이어붙임)

뺄셈, 곱셈, 나눗셈 연산자 -, *, /:뺄셈, 곱셈, 나눗셈은 숫자 연산만 가능하기 때문에, 문자열을 숫자로 암시적 변환합니다.

let 결과1 = "5" - 2; // 숫자 3

let 결과2 = "5" * 2; // 숫자 10

let 결과3 = "10" / "2"; // 숫자 5

**불리언과 숫자의 연산**

let 결과1 = true + 1; // 숫자 2 (true는 1로 변환)

let 결과2 = false + 1; // 숫자 1 (false는 0으로 변환)

**비교 연산자와 형 변환**

동등 연산자==

console.log(5 == "5"); // true (암시적 형 변환 후 비교)

일치 연산자===

console.log(5 === "5"); // false (자료형까지 비교)

# **연산자**

**1. 산술 연산자 (Arithmetic Operators): 숫자간 계산을 할 때 사용된다.**

**덧셈** +: 두 숫자를 더합니다

**뺄셈** -: 첫 번째 숫자에서 두 번째 숫자를 뺍니다.

**곱셈** *: 두 숫자를 곱합니다.

**나눗셈** /: 첫 번째 숫자를 두 번째 숫자로 나눕니다.

**나머지** %: 첫 번째 숫자를 두 번째 숫자로 나눈 후 **나머지**를 구합니다.

**거듭제곱** **: 첫 번째 숫자를 두 번째 숫자만큼 거듭제곱합니다.

let a = 10;

let b = 3;

console.log(a + b); // 출력: 13

console.log(a - b); // 출력: 7

console.log(a * b); // 출력: 30

console.log(a / b); // 출력: 3.333...

console.log(a % b); // 출력: 1

console.log(a ** b); // 출력: 1000 (10의 3제곱)

**2. 할당 연산자 (Assignment Operators):**변수에 값을 **할당(저장)**할 때 사용됩니다.

**기본 할당** =: 오른쪽 값을 왼쪽 변수에 저장합니다.

**기본 할당** =: 오른쪽 값을 왼쪽 변수에 저장합니다.

let x = 10;

x += 5; // x = x + 5, 결과: x는 15

x *= 2; // x = x * 2, 결과: x는 30

**3. 비교 연산자 (Comparison Operators):**값들을 **비교**하여 참(true) 또는 거짓(false)을 반환합니다.

**같음** ==: 두 값이 같으면 참

console.log(5 == '5'); // 출력: true

**일치함** ===: 두 값과 자료형이 모두 같으면 참.

console.log(5 === '5'); // 출력: false (숫자와 문자열은 자료형이 다름)

**다름** !=: 두 값이 다르면 참.

**엄격히 다름** !==: 두 값 또는 자료형이 다르면 참

**크다** >, **작다** <, **크거나 같다** >=, **작거나 같다** <=

let num = 10;

console.log(num > 5);  // 출력: true

console.log(num < 5);  // 출력: false

console.log(num == 10); // 출력: true

console.log(num === '10'); // 출력: false

**4. 논리 연산자 (Logical Operators):**논리값을 조합하거나 반전시킬 때 사용됩니다

**그리고** &&: 두 조건이 모두 참이면 참.

**또는** ||: 두 조건 중 하나라도 참이면 참.

**부정** !: 조건의 반대값을 반환.

let a = true;

let b = false;

console.log(a && b); // 출력: false

console.log(a || b); // 출력: true

console.log(!a);     // 출력: false

**5. 증감 연산자 (Increment and Decrement Operators):**변수의 값을 1씩 증가 또는 감소시킵니다

**증가** ++:

- **전위 증가** ++x: 먼저 값을 1 증가시키고 사용.
- **후위 증가** x++: 값을 사용한 후에 1 증가.

감소도 마찬가지

**6. 삼항 연산자 (Conditional or Ternary Operator):**조건에 따라 값을 선택합니다

**형식**: 조건 ? 참일 때 값 : 거짓일 때 값

let 나이 = 20;

let 성인여부 = 나이 >= 19 ? "성인입니다." : "미성년자입니다.";

console.log(성인여부); // 출력: 성인입니다.

**7. 문자열 연산자 (String Operator):**문자열을 연결할 때 사용합니다.

**연결** +: 두 문자열을 이어붙입니다

let 이름 = "홍길동";

let 인사 = "안녕하세요, " + 이름 + "님!";

console.log(인사); // 출력: 안녕하세요, 홍길동님!

**8. 타입 연산자 (Type Operators):**자료형을 확인하거나 객체를 생성할 때 사용합니다.

typeof: 변수나 값의 자료형을 반환합니다.

console.log(typeof 123); // 출력: "number"

console.log(typeof "hello"); // 출력: "string"

instanceof: 객체가 특정 생성자의 인스턴스인지 확인합니다.

# **조건문**

**1. if 문**

**if 문**은 가장 기본적인 조건문입니다. 조건이 **참(true)**일 경우에만 코드 블록을 실행합니다.

if (조건) {

// 조건이 참일 때 실행되는 코드

}

let 나이 = 20;

if (나이 >= 19) {

console.log("성인입니다.");

}

나이가 19 이상이면 성인입니다가 출력됩니다.

**2. if…else 문**

**if…else 문**은 조건이 **참(true)**일 때와 **거짓(false)**일 때 다른 코드를 실행합니다.

if (조건) {

// 조건이 참일 때 실행되는 코드

} else {

// 조건이 거짓일 때 실행되는 코드

}

let 나이 = 16;

if (나이 >= 19) {

console.log("성인입니다.");

} else {

console.log("미성년자입니다.");

}

나이가 19 미만이면 미성년자입니다가 출력됩니다.

**3. if…else if…else 문**

여러 조건을 순차적으로 검사할 때 사용합니다

if (조건1) {

// 조건1이 참일 때 실행되는 코드

} else if (조건2) {

// 조건2가 참일 때 실행되는 코드

} else {

// 위의 모든 조건이 거짓일 때 실행되는 코드

}

let 점수 = 85;

if (점수 >= 90) {

console.log("A학점입니다.");

} else if (점수 >= 80) {

console.log("B학점입니다.");

} else if (점수 >= 70) {

console.log("C학점입니다.");

} else {

console.log("F학점입니다.");

}

**4. switch 문**

여러 값을 비교해야 할 때 사용하면 코드가 더 간단해짐

switch (표현식) {

case 값1:

// 표현식이 값1과 같을 때 실행되는 코드

break;

case 값2:

// 표현식이 값2와 같을 때 실행되는 코드

break;

default:

// 위의 모든 경우에 해당하지 않을 때 실행되는 코드

}

let 요일 = "월요일";

switch (요일) {

case "월요일":

console.log("한 주의 시작입니다.");

break;

case "금요일":

console.log("주말이 다가옵니다.");

break;

case "토요일":

case "일요일":

console.log("주말입니다!");

break;

default:

console.log("평일입니다.");

}

# **반복문**

**1. for 문:**for 문은 **반복 횟수가 명확할 때** 사용하기 좋습니다

for (초기값; 조건식; 증감식) {

// 반복 실행할 코드

}

for (let i = 1; i <= 5; i++) {

console.log(i);

}

12345 출력됨

**2. while 문:조건이 참(**true**)인 동안** 계속해서 코드를 반복합니다. 반복 횟수가 명확하지 않거나 조건에 따라 반복을 제어하고 싶을 때 사용합니다.

while (조건식) {

// 반복 실행할 코드

}

let i = 1;

while (i <= 5) {

console.log(i);

i++;

}

**3. do...while 문:**do...while 문은 **조건과 상관없이 코드 블록을 최소 한 번은 실행**해야 할 때 사용합니다.

do {

// 반복 실행할 코드

} while (조건식);

let i = 1;

do {

console.log(i);

i++;

} while (i <= 5);

**4. for...of 문 (추가 학습):**for...of 문은 **배열이나 문자열 같은 반복 가능한 객체**를 순회할 때 사용합니다.

for (변수 of 반복가능한객체) {

// 반복 실행할 코드

}

const fruits = ['사과', '바나나', '오렌지'];

for (const fruit of fruits) {

console.log(fruit);

}

**5. 반복문 제어하기: break와 continue:**break: 반복문을 즉시 종료합니다/continue: 현재 반복을 건너뛰고 다음 반복을 시작합니다

for (let i = 1; i <= 10; i++) {

if (i === 5) {

break; // i가 5이면 반복문 종료

}

console.log(i);

}

=1234

for (let i = 1; i <= 5; i++) {

if (i === 3) {

continue; // i가 3이면 아래 코드 건너뜀

}

console.log(i);

}

=1245

# **함수**

**함수**는 **어떤 일을 하는 작은 기계**라고 생각하면 됩니다. 필요한 재료(입력)를 넣으면 결과물을 만들어줍니다.

함수선언하기:

function 함수이름(재료1, 재료2) {

// 여기서 일을 합니다.

}

function 더하기(숫자1, 숫자2) {

let 결과 = 숫자1 + 숫자2;

return 결과;

}

let 합계 = 더하기(3, 5);

console.log(합계); // 출력: 8

**함수의 장점**

**코드 재사용**: 한 번 만들어 두면 여러 번 사용할 수 있어요.

**가독성 향상**: 코드가 더 깔끔해지고 이해하기 쉬워요.

**유지보수 용이**: 기능을 수정할 때 함수만 변경하면 돼요.

function 인사하기(이름) {

console.log("안녕하세요, " + 이름 + "님!");

}

인사하기("영희"); // 출력: 안녕하세요, 영희님!

**콜백 함수**

**:콜백 함수**는 **나중에 호출하기 위해 함수에 전달하는 함수**

- **함수 안에 함수**를 넣는 거예요.
- 이때 전달된 함수는 **필요한 순간에 호출**

function 작업하기(콜백) {

console.log('작업을 시작합니다.');

콜백(); // 전달된 함수를 호출해요.

}

function 작업완료() {

console.log('작업이 완료되었습니다!');

}

작업하기(작업완료);

# **스코프**

**스코프**는 **변수가 어디서부터 어디까지 쓸 수 있는지**를 나타냄

- 변수나 함수가 **유효한 범위**를 말해요.
- 예를 들어, 어떤 변수가 특정 함수 안에서만 쓸 수 있다면, 그 함수가 그 변수의 스코프예요.

**전역 스코프 (Global Scope)**

- **전역 변수**는 **어디서나** 사용할 수 있다
- 함수 밖에서 선언된 변수다

var 전역변수 = "나는 어디서나 쓸 수 있어요";

function 함수() {

console.log(전역변수); // 출력: 나는 어디서나 쓸 수 있어요

}

함수();

console.log(전역변수); // 출력: 나는 어디서나 쓸 수 있어요

**함수 스코프 (Function Scope)**

- **함수 안에서 선언된 변수**는 그 함수 안에서만 쓸 수 있어요.
- var로 선언한 변수는 함수 스코프를 가져요.

function 함수() {

var 함수변수 = "나는 함수 안에서만 쓸 수 있어요";

console.log(함수변수); // 출력: 나는 함수 안에서만 쓸 수 있어요

}

함수();

console.log(함수변수); // 오류 발생: 함수변수를 찾을 수 없어요

**블록 스코프 (Block Scope)**

- ****{} 중괄호로 감싼 부분을 **블록**이라고 해요.
- ****let이나 const로 선언한 변수는 그 블록 안에서만 쓸 수 있어요.

if (true) {

let 블록변수 = "나는 블록 안에서만 쓸 수 있어요";

console.log(블록변수); // 출력: 나는 블록 안에서만 쓸 수 있어요

}

console.log(블록변수); // 오류 발생: 블록변수를 찾을 수 없어요

**스코프 체인 (Scope Chain)**

- ****변수를 찾을 때, 현재 스코프에서 없으면 **한 단계 위 스코프에서 찾는 것**을 말해요.

var 전역변수 = "전역";

function 함수() {

var 함수변수 = "함수";

function 내부함수() {

console.log(전역변수); // 출력: 전역

console.log(함수변수); // 출력: 함수

}

내부함수();

}

함수();

# **객체**

**객체**는 **관련된 데이터와 기능을 한데 모아놓은 것**이에요.

**속성(프로퍼티)**: 색상, 브랜드, 속도 등

**동작(메서드)**: 출발하기, 멈추기, 속도 변경하기 등

**객체를 만드는 방법:**중괄호 {}를 사용해서 객체를 만들 수 있어요.

**let 사람 = {**

**이름: "홍길동",**

**나이: 25,**

**인사하기: function() {**

**console.log("안녕하세요, 저는 " + this.이름 + "입니다.");**

**}**

**};**

**속성: 이름,나이**

**매서드: 인사하기**

**객체의 속성(프로퍼티)에 접근하기**

**점표기법: console.log(사람.이름); // 출력: 홍길동**

**대괄호 표기법: console.log(사람["나이"]); // 출력: 25**

**객체의 메서드 호출하기**

**사람.인사하기(); // 출력: 안녕하세요, 저는 홍길동입니다.**

**객체에 속성 추가 및 수정하기**

**속성추가:사람.성별 = "남성";**

**console.log(사람.성별); // 출력: 남성**

**속성수정:사람.나이 = 26;**

**console.log(사람.나이); // 출력: 26**

# **배열**

**배열**은 **여러 개의 데이터를 순서대로 저장하는 상자**라고 생각하시면 돼요. 예를 들어, 친구들의 이름을 한 곳에 모아두고 싶을 때 배열을 사용할 수 있어요.

**배열 생성하기:**대괄호 []를 사용하여 배열을 만들 수 있다

let 과일들 = ["사과", "바나나", "오렌지"];

**배열의 요소에 접근:**배열의 각 데이터는 **인덱스(index)**라는 번호로 접근할 수 있어요. 인덱스는 **0부터 시작**해요.

console.log(과일들[0]); // 출력: 사과

console.log(과일들[1]); // 출력: 바나나

console.log(과일들[2]); // 출력: 오렌지

**끝에 추가하기: push 메서드**

**과일들.push("포도");**

**console.log(과일들); // 출력: ["사과", "바나나", "오렌지", "포도"]**

**앞에 추가하기: unshift 메서드**

**과일들.unshift("딸기");**

**console.log(과일들); // 출력: ["딸기", "사과", "바나나", "오렌지", "포도"]**

**배열의 길이 확인하기**

배열의 길이는 length 속성으로 알 수 있다

console.log(과일들.length); // 출력: 3 과일들 배열 3개